# POD 相关解释 #
 
- POD，全称plain old data，
- plain代表它是一个普通类型，
- old代表它可以与c兼容，可以使用比如memcpy()这类c中最原始函数进行操作。
 
 C++11中把POD分为了两个基本概念的集合，即：**平凡的**（trivial）和**标准布局的**（standard layout）。



> 一、平凡的（trivial）定义：
>
1. 拥有平凡的默认构造函数和析构函数。默认的意思就是由编译器为我们自动生成的，不许是我们自己定义的，但是由于c++11提供了default，也可以是自己定义的加=default
2. 拥有平凡的拷贝构造函数和移动构造函数。默认的意思同上，也可以使用=default。
3. 拥有平凡的拷贝赋值操作符和移动赋值操作符。
4. 不能包含虚函数和虚基类

> 二、标准布局的定义
> 
1. 在类和结构体继承时需要满足以下两个情况之一：
		派生类中有非静态类，那么这个派生类只能有且只有一个仅包含了静态成员的基类。
		基类有非静态成员，那么派生类中不允许有非静态成员。
	（这两句话看着挺绕口，其实就是在说明一个事实，关于非静态数据的事实，派生类中有非静态的数据那么它的基类只能是只有静态的，而且基类只能有一个。如果基类有非静态的，那么派生类就不能有非静态的。有种跷跷板的感觉，非静态的对面坐着的是静态，父子类就是坐在跷跷板的两端这种对应关系。）
2. 类中第一个非静态类型与基类不是同一个类型。比如
	`struct A:B{
   		B b;
   		int c;
	}`
就不符合这个条件。因为A中第一个成员是基类B类型的。
3. 没有虚类和虚基类（与trival中重复）
4. 所有非静态数据成员都符合标准布局的要求，这其实就是一个递归的定义。

> 三、POD到底有什么好处呢?
> 
1. 字节赋值, 代码中我们可以安全的使用memset和memcpy函数对POD类型进行初始化和拷贝等操作.
2. 提供了对C内存布局的兼容. C++程序可以与C函数 进行相互的操作, 因为POD类型的数据在C++与C之间的操作总是安全的.
3. 保证了静态初始化的安全有效, 静态初始化在很多时候能够提高程序的性能, 而POD类型的对象初始化往往更加简单(比如放在目标文件的.bss段 , 在初始化中直接被赋0).